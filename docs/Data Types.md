# Functional PHP Preprocessor - Immutable data type generator

## Data Types

### Basics

Data types are the thing where FPP really shines. You've learned how to generate
simple wrappers around PHP scalar types like string, int, bool, float as well as
uuid, guid and enum. We can use those base types to generate more complex types.

Let's say we need a class with the following constructor:

```
class Address
{
    // properties here

    public function __construct(
        string $street,
        string $number,
        string $zipCode,
        string $country
    ) {
        // more code here
    }

    // a bunch of setters here

    // toArray-method

    // fromArray-constructor

    // equals method
}
```

As you can see, this would be a lot of code to type, so let's see how the same thing
can be generated by FPP without typing all this boilerplate.

```
namespace Foo;

data Address = { string $street, string $number, string $zipCode, string $country };
```

Of course, you can also add marker interfaces again:

```
namespace Foo;

data Address : MyMarker = { string $street, string $number, string $zipCode, string $country };
```


So that's a lot less code to type! We can also use our base types, so let's do this
by example again and use an enum for our country parameter as well:

```
namespace Foo;

string Street;
string Number;
string ZipCode;
enum CountryName = US | PY | CA | UK;

data Address = { Street $street, Number $number, ZipCode $zipCode, Country $country };
```

As you might notice, using base types, the parameter name and type are usually the same,
so we can also avoid it:

```
namespace Foo;

data Address = { Street, Number, ZipCode, Country };
```

But what happens if you need to use the same type twice in a constructor?
For example we can think of a user having a user id and a parent user id.
Let's have a look:

```
namespace Foo;

uuid UserId;
string FirstName;
string LastName;
int Age;

data User = { UserId, UserId, FirstName, LastName, Age };
```

This would generate the following parameter names:

`$userId, $userId2, $firstName, $lastName, $age`

That's already pretty good, but most likely you want to name the second parameter
according to its purpose `$parentUserId`. That's no big deal at all!

```
namespace Foo;

data User = { UserId, UserId $parentUserId, FirstName, LastName, Age };
```

### Nullable types, array-bracket syntax and default values

Array-bracket syntax is very importing if you are dealing with lists of things,
and nullable types when a property is optional. Of course, you can also add
default values:

```
namespace Foo;

data User = { string $name = 'Guest', ?int $parentUserId, string[] $hobbies };
```

### Importing classes from another namespace

You can use the same syntax (also using aliases) as you would use in plain PHP.
So the following would work and generate you usable PHP code:

```
namespace Foo {

    string FullName;
    string Hobbie;
}

namespace Foo\Bar {
    use Foo\FullName as Name;
    use Foo\Hobbie;

    data Person = { Name, Hobbie[] };
}
```

### Subclasses

Let's assume you need to have an `Animal` abstract class and its implementations
`Cat`, `Dog` and `Bird`. Let's have a look:

```
namespace Foo;

data Animal =
    Cat { string $name, int $age }
    | Dog { string $name, int $age, string $ownersName }
    | Bird { string $name };
```

### DateTimeImmutable

You can reuse DateTimeImmutable class by default in FPP, just import it first:

```
namespace Foo;

use DateTimeImmutable;

uuid UserId;
string Name;
data User = { UserId, DateTimeImmutable $registeredAt, Name };
```

Next, let's have look on how to reuse existing classes in FPP. In order to do that
you need to configure FPP a little and make it aware on how those classes, external
to FPP work. See [Configuration](Configuration.md).
