<?php

/**
 * This file is part of prolic/fpp.
 * (c) 2018-2020 Sascha-Oliver Prolic <saschaprolic@googlemail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace Fpp;

use Nette\PhpGenerator\PsrPrinter;
use function Pair;
use Phunkie\Types\Pair;

if (! isset($argv[1])) {
    echo 'Missing input directory or file argument';
    exit(1);
}

$path = $argv[1];

$pwd = \realpath(\getcwd());
$vendorName = 'vendor';

if (\file_exists($composerPath = "$pwd/composer.json")) {
    $composerJson = \json_decode(\file_get_contents($composerPath), true);
    $vendorName = isset($composerJson['config']['vendor-dir']) ? $composerJson['config']['vendor-dir'] : $vendorName;
}

if (! \file_exists("$pwd/$vendorName/autoload.php")) {
    echo "\033[1;31mYou need to set up the project dependencies using the following commands: \033[0m" . PHP_EOL;
    echo 'curl -s http://getcomposer.org/installer | php' . PHP_EOL;
    echo 'php composer.phar install' . PHP_EOL;
    exit(1);
}

$autoloader = require "$pwd/$vendorName/autoload.php";

$prefixesPsr4 = $autoloader->getPrefixesPsr4();
$prefixesPsr0 = $autoloader->getPrefixes();

$locatePsrPath = function (string $classname) use ($prefixesPsr4, $prefixesPsr0): string {
    return locatePsrPath($prefixesPsr4, $prefixesPsr0, $classname);
};

require_once "$pwd/autoload.php";

$config = [
    'use_strict_types' => true,
    'printer' => fn () => (new PsrPrinter())->setTypeResolving(false),
    'file_parser' => parseFile,
    'comment' => 'Generated by prolic/fpp - do not edit !!!',
    'types' => [
        Type\Command\Command::class => Type\Command\typeConfiguration(),
        Type\Data\Data::class => Type\Data\typeConfiguration(),
        Type\Enum\Enum::class => Type\Enum\typeConfiguration(),
        Type\Event\Event::class => Type\Event\typeConfiguration(),
        Type\String_\String_::class => Type\String_\typeConfiguration(),
        Type\Int_\Int_::class => Type\Int_\typeConfiguration(),
        Type\Float_\Float_::class => Type\Float_\typeConfiguration(),
        Type\Bool_\Bool_::class => Type\Bool_\typeConfiguration(),
        Type\Marker\Marker::class => Type\Marker\typeConfiguration(),
        Type\Uuid\Uuid::class => Type\Uuid\typeConfiguration(),
        Type\Guid\Guid::class => Type\Guid\typeConfiguration(),
        \DateTimeImmutable::class => Type\DateTimeImmutable\typeConfiguration(),
    ],
];

if ($path === '--gen-config') {
    $file = <<<CODE
<?php

declare(strict_types=1);

namespace Fpp;

use Nette\PhpGenerator\PsrPrinter;

return [
    'use_strict_types' => true,
    'printer' => fn () => (new PsrPrinter())->setTypeResolving(false),
    'file_parser' => parseFile,
    'comment' => 'Generated by prolic/fpp - do not edit !!!', // put `null` to disable
    'types' => [
        Type\Command\Command::class => Type\Command\typeConfiguration(),
        Type\Data\Data::class => Type\Data\typeConfiguration(),
        Type\Enum\Enum::class => Type\Enum\typeConfiguration(),
        Type\Event\Event::class => Type\Event\typeConfiguration(),
        Type\String_\String_::class => Type\String_\typeConfiguration(),
        Type\Int_\Int_::class => Type\Int_\typeConfiguration(),
        Type\Float_\Float_::class => Type\Float_\typeConfiguration(),
        Type\Bool_\Bool_::class => Type\Bool_\typeConfiguration(),
        Type\Marker\Marker::class => Type\Marker\typeConfiguration(),
        Type\Uuid\Uuid::class => Type\Uuid\typeConfiguration(),
        Type\Guid\Guid::class => Type\Guid\typeConfiguration(),
        \DateTimeImmutable::class => Type\DateTimeImmutable\typeConfiguration(),
    ],
];

CODE;

    \file_put_contents("$pwd/fpp-config.php", $file);

    echo "Default configuration written to $pwd/fpp-config.php\n";
    exit(0);
}

if (\file_exists("$pwd/fpp-config.php")) {
    $config = require "$pwd/fpp-config.php";
}

$config = Configuration::fromArray($config);

$parser = \array_reduce(
    \array_filter(
        $config->types(),
        fn (TypeConfiguration $c) => $c->parse() !== null
    ),
    fn (Parser $p, TypeConfiguration $c) => $p->or($c->parse()()),
    zero()
);

$definitions = \array_map(
    fn ($f) => Pair(($config->fileParser())($parser)->run(\file_get_contents($f)), $f),
    scan(
        $path
    )
);

$definitions = \array_map(
    function (Pair $p) {
        $parsed = $p->_1;
        $filename = $p->_2;

        $p = $parsed[0];

        if ($p->_2 !== '') {
            echo "\033[1;31mSyntax error at file: $filename\033[0m" . PHP_EOL;
            echo $p->_2;
            exit(1);
        }

        return $p->_1;
    },
    $definitions
);

$definitions = \array_reduce(
    $definitions,
    fn (array $l, array $nds) => \array_merge($l, $nds),
    []
);

$definitions = \array_reduce(
    $definitions,
    function (array $ds, array $nds) {
        foreach ($nds as $n => $d) {
            $ds[$n] = $d;
        }

        return $ds;
    },
    [],
);

$dumpedDefinitions = [];

foreach ($definitions as $name => $definition) {
    $dumpedDefinitions[$name] = dump($definition, $definitions, $config);
}

foreach ($dumpedDefinitions as $name => $files) {
    foreach ($files as $fqcn => $code) {
        $filename = $locatePsrPath($fqcn);
        $directory = \dirname($filename);

        if (! \is_dir($directory)) {
            \mkdir($directory, 0777, true);
        }

        \file_put_contents($filename, $code);
    }
}

echo "Successfully generated and written to disk\n";
exit(0);
